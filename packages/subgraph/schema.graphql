type System @entity {
  "There should be only one System entity with an ID of 'only'"
  id: ID!

  transactionCount: Int!
  changeCount: Int!
  liquidationCount: Int!

  currentPrice: BigDecimal!

  "Only used internally as temporary storage. Will always be null in queries"
  currentLiquidation: Liquidation
}

type User @entity {
  "User's Ethereum address as a hex-string"
  id: ID!

  currentTrove: Trove
  troveCount: Int!

  currentStabilityDeposit: StabilityDeposit
  stabilityDepositCount: Int!

  troves: [Trove!]! @derivedFrom(field: "owner")
  stabilityDeposits: [StabilityDeposit!]! @derivedFrom(field: "owner")
  liquidations: [Liquidation!]! @derivedFrom(field: "liquidator")
}

type Trove @entity {
  "Owner's ID + '-' + an incremented integer"
  id: ID!

  owner: User!

  collateral: BigDecimal!
  debt: BigDecimal!

  changes: [TroveChange!]! @derivedFrom(field: "trove")

  rawCollateral: BigInt!
  rawDebt: BigInt!
  rawStake: BigInt!

  "Collateral divided by debt. Can be used to sort by collateral ratio."
  rawCollateralPerDebt: BigInt!

  "The value of total redistributed per-stake collateral the last time rewards were applied"
  rawSnapshotOfTotalRedistributedCollateral: BigInt!

  "The value of total redistributed per-stake debt the last time rewards were applied"
  rawSnapshotOfTotalRedistributedDebt: BigInt!
}

type StabilityDeposit @entity {
  "Owner's ID + '-' + an incremented integer"
  id: ID!

  owner: User!

  depositedAmount: BigDecimal!

  changes: [StabilityDepositChange!]! @derivedFrom(field: "stabilityDeposit")
}

type Transaction @entity {
  "Transaction hash"
  id: ID!

  "Can be used to correctly sort transactions even if they were mined in the same block"
  sequenceNumber: Int!

  blockNumber: Int!

  "Timestamp of block that included this transaction (seconds since epoch)"
  timestamp: Int!

  changes: [Change!]! @derivedFrom(field: "transaction")
}

interface Change {
  "Same as sequence number, but as an ID (string)"
  id: ID!

  "Can be used to correctly sort changes even if they were made by the same transaction"
  sequenceNumber: Int!

  "Transaction that made this change"
  transaction: Transaction!
}

enum TroveOperation {
  openLoan
  closeLoan
  depositCollateral
  withdrawCollateral
  mint
  repay
  adjustLoan
  accrueRewards
  liquidateInNormalMode
  liquidateInRecoveryMode
  partiallyLiquidateInRecoveryMode
  redeemCollateral
}

type TroveChange implements Change @entity {
  id: ID!
  sequenceNumber: Int!
  transaction: Transaction!

  trove: Trove!
  troveOperation: TroveOperation!
  price: BigDecimal!

  collateralBefore: BigDecimal!
  collateralChange: BigDecimal!
  collateralAfter: BigDecimal!

  debtBefore: BigDecimal!
  debtChange: BigDecimal!
  debtAfter: BigDecimal!

  collateralRatioBefore: BigDecimal
  collateralRatioAfter: BigDecimal

  liquidation: Liquidation
}

enum StabilityDepositOperation {
  depositTokens
  withdrawTokens
  withdrawCollateralGain
}

type StabilityDepositChange implements Change @entity {
  id: ID!
  sequenceNumber: Int!
  transaction: Transaction!

  stabilityDeposit: StabilityDeposit!
  stabilityDepositOperation: StabilityDepositOperation!

  depositedAmountBefore: BigDecimal!
  depositedAmountChange: BigDecimal!
  depositedAmountAfter: BigDecimal!

  collateralGain: BigDecimal
}

type PriceChange implements Change @entity {
  id: ID!
  sequenceNumber: Int!
  transaction: Transaction!

  priceBefore: BigDecimal!
  priceChange: BigDecimal!
  priceAfter: BigDecimal!
}

type Liquidation @entity {
  id: ID!
  sequenceNumber: Int!
  transaction: Transaction!
  liquidator: User!

  liquidatedDebt: BigDecimal!
  liquidatedCollateral: BigDecimal!
  gasCompensation: BigDecimal!

  troveChanges: [TroveChange!]! @derivedFrom(field: "liquidation")
}
